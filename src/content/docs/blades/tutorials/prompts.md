---
title: "Prompt"
---
In the Blades framework, Prompt is the core component for interacting with large language models (LLMs). It represents a sequence of messages exchanged between the user and the assistant, supporting multiple types of messages (system messages, user messages, assistant messages) as well as templating functionality, enabling developers to build dynamic and context-aware AI applications.

### Message
Blades supports multiple message types, each with a specific role:
- RoleUser: Represents the end user's input
- RoleSystem: Provides system-level instructions and context
- RoleAssistant: Represents the model's output
- RoleTool: Represents messages generated by tools
```go
// Message represents a single message in a conversation.
type Message struct {
	ID           string         `json:"id"`
	Role         Role           `json:"role"`
	Parts        []Part         `json:"parts"`
	Author       string         `json:"author"`
	InvocationID string         `json:"invocationId,omitempty"`
	Status       Status         `json:"status"`
	FinishReason string         `json:"finishReason,omitempty"`
	TokenUsage   TokenUsage     `json:"tokenUsage,omitempty"`
	Metadata     map[string]any `json:"metadata,omitempty"`
}
// TextPart is plain text content.
type TextPart struct {
	Text string `json:"text"`
}
```

## User Prompt
The most basic way to create a Prompt is by directly specifying the message content:
```go
input := blades.UserMessage("What is the capital of France?")
```

### System Instruction Prompt
System instructions can be defined through the Agent:
```go
model := openai.NewModel("gpt-5", openai.Config{
	APIKey: os.Getenv("OPENAI_API_KEY"),
})
agent, err := blades.NewAgent(
	"Basic Agent",
	blades.WithModel(model),
	blades.WithInstructions("You are a helpful assistant that provides detailed and accurate information."),
)
```

#### Template with Session Context
```go
model := openai.NewModel("gpt-5", openai.Config{
	APIKey: os.Getenv("OPENAI_API_KEY"),
})
agent, err := blades.NewAgent(
	"Instructions Agent",
	blades.WithModel(model),
	blades.WithInstructions("Respond as a {{.style}}."),
)
if err != nil {
	log.Fatal(err)
}
// Create a new session with state variables
session := blades.NewSession(map[string]any{
	"style": "robot",
})
input := blades.UserMessage("Tell me a joke.")
runner := blades.NewRunner(agent, blades.WithSession(session))
message, err := runner.Run(context.Background(), input)
if err != nil {
	panic(err)
}
log.Println(session.State())
log.Println(message.Text())
```

### Best Practices
- Clear System Instructions: Provide clear and specific instructions in system messages to help the model better understand task requirements.
- Use Templates Appropriately: Utilize templating functionality to improve code reusability and maintainability, especially in scenarios requiring dynamic Prompt generation.
- Manage Context Length: Pay attention to controlling the Prompt length to avoid exceeding the model's maximum context limit.
- Error Handling: Always check for errors during template rendering and Prompt construction processes to ensure application robustness.