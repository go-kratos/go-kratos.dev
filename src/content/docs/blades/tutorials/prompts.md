---
title: "Prompt"
---
In the Blades framework, Prompt is the core component for interacting with large language models (LLMs). It represents the sequence of messages exchanged between the user and the assistant, supporting various types of messages (system messages, user messages, assistant messages) as well as templating capabilities, enabling developers to build dynamic and context-aware AI applications.

### Message Types
Blades supports multiple message types, each with a specific role:
- RoleUser: Represents the end user's input
- RoleSystem: Provides system-level instructions and context
- RoleAssistant: Represents the model's output
- RoleTool: Represents messages generated by tools

## User Prompt
The most basic way to create a Prompt is by directly specifying the message content:
```go
input := blades.UserMessage("What is the capital of France?")
```

### System Instruction Prompt
System instructions can be defined through the Agent:
```go
agent, err := blades.NewAgent(
	"Basic Agent",
	blades.WithModel("gpt-5"),
	blades.WithProvider(openai.NewChatProvider()),
	blades.WithInstructions("You are a helpful assistant that provides detailed and accurate information."),
)
```

#### Template with Session Context
```go
agent, err := blades.NewAgent(
	"Instructions Agent",
	blades.WithModel("gpt-5"),
	blades.WithProvider(openai.NewChatProvider()),
	blades.WithInstructions("Respond as a {{.style}}."),
)
if err != nil {
	log.Fatal(err)
}
// Create a new session
session := blades.NewSession(map[string]any{
	"style": "robot",
})
input := blades.UserMessage("Tell me a joke.")
// Run the agent with the prompt and session context
runner := blades.NewRunner(agent, blades.WithSession(session))
ctx := context.Background()
message, err := runner.Run(ctx, input)
if err != nil {
	panic(err)
}
log.Println(session.State())
log.Println(message.Text())
```

### Best Practices
- Clear System Instructions: Provide clear and specific instructions in system messages to help the model better understand task requirements.
- Proper Use of Templates: Utilize templating capabilities to improve code reusability and maintainability, especially in scenarios requiring dynamic Prompt generation.
- Manage Context Length: Pay attention to controlling the Prompt length to avoid exceeding the model's maximum context limit.
- Error Handling: Always check for errors during template rendering and Prompt construction to ensure application robustness.