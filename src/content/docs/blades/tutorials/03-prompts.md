---
title: "Prompt"
---
In the Blades framework, Prompt is the core component for interacting with large language models (LLMs). It represents a sequence of messages exchanged between the user and the assistant, supporting various message types (system messages, user messages, assistant messages) and templating capabilities, enabling developers to build dynamic and context-aware AI applications.

### Message
Blades supports multiple message types, each with a specific role:
- RoleUser: Represents end-user input
- RoleSystem: Provides system-level instructions and context
- RoleAssistant: Represents the model's output
- RoleTool: Represents messages generated by tools
```go
// Message represents a single message in a conversation.
type Message struct {
	ID           string         `json:"id"`
	Role         Role           `json:"role"`
	Parts        []Part         `json:"parts"`
	Author       string         `json:"author"`
	InvocationID string         `json:"invocationId,omitempty"`
	Status       Status         `json:"status"`
	FinishReason string         `json:"finishReason,omitempty"`
	TokenUsage   TokenUsage     `json:"tokenUsage,omitempty"`
	Metadata     map[string]any `json:"metadata,omitempty"`
}
// TextPart is plain text content.
type TextPart struct {
	Text string `json:"text"`
}
```

## User Prompt
The most basic way to create a Prompt is by directly specifying the message content:
```go
input := blades.UserMessage("What is the capital of France?")
```

### System Instruction Prompt
System instruction information can be defined via an Agent:
```go
model := openai.NewModel("gpt-5", openai.Config{
	APIKey: os.Getenv("OPENAI_API_KEY"),
})
agent, err := blades.NewAgent(
	"Basic Agent",
	blades.WithModel(model),
	blades.WithInstruction("You are a helpful assistant that provides detailed and accurate information."),
)
```

#### Template with Session Context
```go
model := openai.NewModel("gpt-5", openai.Config{
	APIKey: os.Getenv("OPENAI_API_KEY"),
})
agent, err := blades.NewAgent(
	"Instructions Agent",
	blades.WithModel(model),
	blades.WithInstruction("Respond as a {{.style}}."),
)
if err != nil {
	log.Fatal(err)
}
// Create a new session with state variables
session := blades.NewSession(map[string]any{
	"style": "robot",
})
input := blades.UserMessage("Tell me a joke.")
runner := blades.NewRunner(agent)
message, err := runner.Run(context.Background(), input, blades.WithSession(session))
if err != nil {
	panic(err)
}
log.Println(session.State())
log.Println(message.Text())
```

### Best Practices
- Clear System Instructions: Provide clear and specific instructions in system messages to help the model better understand task requirements.
- Use Templates Appropriately: Leverage templating capabilities to improve code reusability and maintainability, especially in scenarios requiring dynamic Prompt generation.
- Manage Context Length: Pay attention to controlling Prompt length to avoid exceeding the model's maximum context limit.
- Error Handling: Always check for errors during template rendering and Prompt construction to ensure application robustness.